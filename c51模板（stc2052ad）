/*****************************************************************************
2019/12/3 22:06
此文件为实例程序 方便复制使用
*****************************************************************************/


/*****************************************************************************
头文件
#include <STC12C2052AD.h>
#include <reg51.h>
#include <STC89C5xRC.H>
*****************************************************************************/



/*****************************************************************************



/*****************************************************************************
毫秒延时程序
void delay(unsigned int a){
	unsigned int i;
	while( a-- != 0){
		for(i = 0; i < 600; i++);
	}
}
*****************************************************************************/



/*****************************************************************************
外部中断开关0
void INIT0_open(void){
  EA=1;
  EX0=1;
	IT0=1;//工作方式为1时 高到低或低到高瞬间触发一个循环，然后回到主循环 为0时低电平时循环触发，变为高电平时回到主循环
	//PX0=1;//设置为最高优先级
}

//发生中断后直接进入下列程序
void onecut(void) interrupt 0 using 0{
  //内容
}
*****************************************************************************/




/*****************************************************************************
外部中断开关1
void INIT1_open(void){
  EA=1;
  EX1=1;
	IT1=1;//工作方式为1时 高到低或低到高瞬间触发一个循环，然后回到主循环 为0时低电平时循环触发，变为高电平时回到主循环
	//PX1=1;//设置为最高优先级
}

//发生中断后直接进入下列程序
void towcut(void) interrupt 2 using 2{
  //内容
}
*****************************************************************************/




/*****************************************************************************
io空工作状态设置

	P1M0=0x00;
	P1M1=0xff;//p1 io口设为强推模式 只能输出 不能输入
	
	P1M0=0xff;
	P1M1=0x00;//高阻态输入模式 只能输入 无电流 初始状态为0

	P1M0=0x00;
	P1M1=0x00;//设为标准双向口 可输入可输出
	
	
P0	  80H	P07	P06	P05	P04	P03	P02	P01	P00
POM0	93H	0		0		0		0		0		0		0   0
POM1	94H 0		0		0		0		0		0		0   0
*****************************************************************************/



/*****************************************************************************
pwm

开关
void PWM_init (void){
  CMOD=0x02; 
 	CL=0x00; 
 	CH=0x00;
//若打开则开启pwm0
	CCAPM0=0x42; 
 	CCAP0L=0x00; 
 	CCAP0H=0x00; 
//若打开则开启pwm1
	//CCAPM1=0x42; 
	//CCAP1L=0x00;
 	//CCAP1H=0x00; 
//若打开则开启pwm2
	//CCAPM2=0x42; 
	//CCAP2L=0x00; 
 	//CCAP2H=0x00; 
//若打开则开启pwm3
	//CCAPM3=0x42;
	//CCAP3L=0x00;
 	//CCAP3H=0x00;

 	CR=1;
}
设置pwm0占空比
void PWM0_set (unsigned char a){
	CCAP0L= a; 
 	CCAP0H= a; 
}
设置pwm1占空比
void PWM1_set (unsigned char a){
	CCAP1L= a; 
 	CCAP1H= a; 
}
*****************************************************************************/



/*****************************************************************************
定时计数器中断


void TC_open (void){
	EA = 1;	//中断总开关
	TMOD = 0x11; //设置T/C0 和TC1的工作方式 [ GATE,C/T,M1,M0,GATE,C/T,M1,M0 ] M0 M1 1 0 为高16位计数 C/T为1时做计数器 为0时做定时器
	
  ET0 = 1; //T/C0中断开关
	TH0 = 0x13; 
	TL0 = 0x13; //设置定时计数器0初值(0x3CB0 = 50mS)
	TR0 = 1; //T/C0开启
	
	ET1 = 1; //T/C1中断开关
	TH1 = 0xFE; //
	TL1 = 0xFE; //设置定时计数器0初值(0x3CB0 = 50mS)
	TR1 = 1; //T/C1开启
}

进入中断后TH TL自动清零
void TC0 (void) interrupt 1  using 1{ 
	TH0 = 0x3C; 
	TL0 = 0xB0; 
	//内容
}

void TC1 (void) interrupt 3  using 3{ 
	TH1 = 0x3C; 
	TL1 = 0xB0; 
	//内容
}

*****************************************************************************/



/*****************************************************************************
串口初始化
12mhz
void UART_init (void){
	//EA = 1; //允许总中断（如不使用中断，可用//屏蔽）
	ES = 1; //允许UART串口的中断

	TMOD = 0x20;	//定时器T/C1工作方式2
	SCON = 0x50;	//串口工作方式1，允许串口接收（SCON = 0x40 时禁止串口接收）
	TH1 = 0xF3;	//定时器初值高8位设置
	TL1 = 0xF3;	//定时器初值低8位设置
	PCON = 0x80;	//波特率倍频（屏蔽本句波特率为2400）
	TR1 = 1;	//定时器启动    
}

11.509mhz
void UART_init (void){
	//EA = 1; //允许总中断（如不使用中断，可用//屏蔽）
	ES = 1; //允许UART串口的中断

	TMOD = 0x20;	//定时器T/C1工作方式2
	SCON = 0x50;	//串口工作方式1，允许串口接收（SCON = 0x40 时禁止串口接收）
	TH1 = 0xFD;	//定时器初值高8位设置
	TL1 = 0xFD;	//定时器初值低8位设置
	PCON = 0x80;	//波特率倍频（屏蔽本句波特率为9600）
	TR1 = 1;	//定时器启动    
}
*****************************************************************************/




/*****************************************************************************
接受到数据后进入中断 发送的数据以16进制存放在UART_data中
void UART_R (void) interrupt 4  using 1{ //切换寄存器组到1
	unsigned char UART_data; //定义串口接收数据变量
	RI = 0;			//令接收中断标志位为0（软件清零）
	UART_data = SBUF;	//将接收到的数据送入变量 UART_data
	
	if (UART_data==2){
	//内容
	}

	SBUF = UART_data;	//将接收的数据发送回去（删除//即生效）仅仅为了数据可视化
	while(TI == 0);	//检查发送中断标志位
	TI = 0;		//令发送中断标志位为0（软件清零）
}	
*****************************************************************************/



/****************************************************************************
函数名：UART串口发送函数
结  果：将参数中的数据以16进制发送给UART串口

void UART_T (unsigned char UART_data){ //定义串口发送数据变量
	SBUF = UART_data;	//将接收的数据发送回去
	while(TI == 0);		//检查发送中断标志位
	TI = 0;			//令发送中断标志位为0（软件清零）
}

当要配合UART_TC（）函数进行文本输出时 要加0x30 比如要输出5 在文本模式下应为UART_T(0x30+5) 最多加9
***************************************************************************/



/*********************************************************************************************
函数名：UART串口发送字符串函数
结  果：向串口发送一个字符串,长度不限.

void UART_TC (unsigned char *str){
	while(*str != '\0'){
		UART_T(*str);
		*str++;
	}
	*str = 0;
}
*********************************************************************************************/
